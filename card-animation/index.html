<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Animation Demonstrations</title>
  <script>
  const startDemos = () => {
    const demoNode = document.getElementById('demo')
    const naiveDemoNode = document.getElementById('naiveDemo')

    if (demoNode && startDemos.spriteLoaded) {
      Elm.Explanation.Main.embed(demoNode, Math.floor(Math.random() * 10000))
    }

    if (naiveDemoNode && startDemos.spriteLoaded) {
      Elm.Explanation.Naive.embed(naiveDemoNode)
    }
  }
  </script>
  <link rel="preload" href="public/img/sprite.png" as="image" type="image/png" onload="startDemos.spriteLoaded = true; startDemos()">
  <link rel="stylesheet" href="public/node_modules/codemirror/lib/codemirror.css">
  <link rel="stylesheet" href="public/node_modules/codemirror/theme/monokai.css">
  <link rel="stylesheet" type="text/css" href="public/css/blog-theme.css">
  <script src="public/js/define-custom-element.js"></script>
  <link rel="stylesheet" href="public/css/variables.css">
  <link rel="stylesheet" href="public/css/table-top.css">
  <link rel="import" href="public/html/pilatch-card.html">
  <script src="public/node_modules/codemirror/lib/codemirror.js"></script>
  <script src="public/node_modules/codemirror/mode/css/css.js"></script>
  <script src="public/node_modules/codemirror/mode/elm/elm.js"></script>
  <script src="public/node_modules/codemirror/mode/xml/xml.js"></script>
  <script src="public/js/Elm.Explanation.js"></script>
  <style>
  main .table-top, #demo, #naiveDemo {
    --table-top-height: 400px;
    height: var(--table-top-height);
    margin-top: 1em;
  }
  main .player-placed-card-area {
    top: 45px;
  }
  .player-hand {
    top: 250px;
  }
  </style>
</head>
<body onload="startDemos()">
  <main>
    <header>
      <h1>Card Animations</h1>
      <p>Using web components, Elm, and CSS transitions</p>
    </header>
    <figure>
      <section id="demo"></section>
      <figcaption>A hand with cards being randomly placed to simulate user interaction</figcaption>
    </figure>
    <p>I wanted to make an online game with cards moving realistically between players' hands and the table-top.</p>
    <p>
      In the past I had developed <a href="https://pilatch.com/games/casual/Runway">game demonstrations</a> that were meant to augment textual rules.
      Those used <a href="https://jquery.com/">jQuery</a> animations, which is impossible to replicate today because the web police would confiscate my license to dev.
    </p>
    <h2>Web Components</h2>
    <p>Instead my modern approach was to create a <a href="https://www.webcomponents.org/">web component</a> for each zone in the game:</p>
    <figure>
      <code-mirror mode="xml"><!--
<table-top>
  <pilatch-hand>
    <pilatch-card rank="12" suit="scissors"></pilatch-card>
    <pilatch-card rank="7" suit="paper"></pilatch-card>
    <pilatch-card rank="1" suit="paper"></pilatch-card>
  </pilatch-hand>
  <placed-card-area>
    <pilatch-card rank="10" suit="rock"></pilatch-card>
  </placed-card-area>
  <!-- ... --&gt;
</table-top>
--></code-mirror>
      <figcaption>A hand of three pilatch cards with the ten-of-rock placed on the table</figcaption>
    </figure>
    <p>
      Each web component was responsible for positioning its children, which was great for abstraction and separation of concerns.
      Unfortunately it failed because the concept of moving a card between zones didn't apply in virtual DOM.
      <a href="http://elm-lang.org/">Elm</a>'s renderer would destroy the card element that was in the hand, and re-make it at its destination.
      The result was more teleportation than animation.
    </p>
    <p>
      My next attempt featured a single table-top element that would contain each card <em>without</em> additional nesting.
      Cards fly about the table top by adding or removing HTML attributes or CSS classes from them.
    </p>
    <figure>
      <code-mirror mode="css"><!--
.table-top {
  position: relative;
}
.table-top pilatch-card {
  position: absolute;
  will-change: left, top; /* for performance! */
}

[hand] { top: 80%; }
[hand=1] { left: 0; }
[hand=2] { left: 20%; }
/* ... more [hand=n] styles ... */

[placed] {
  top: 50%;
  left: 33.3%;
}
--></code-mirror>
      <figcaption>A simplified snippet of table-top CSS</figcaption>
    </figure>
    <p>Now a card in hand could move to the table just by adding an attribute to it, such as <code>placed</code>.</p>
    <figure>
      <code-mirror mode="xml"><!--
<pilatch-card hand="1" rank="12" suit="scissors"></pilatch-card>
<pilatch-card hand="2" rank="7" suit="paper"></pilatch-card>
<pilatch-card placed hand="3" rank="10" suit="rock"></pilatch-card>
<pilatch-card hand="4" rank="1" suit="paper"></pilatch-card>
--></code-mirror>
      <figcaption>A hand of four pilatch cards, with the ten of rock transitioning to the table</figcaption>
    </figure>
    <p>
      Yet this approach is na√Øve because it's still necessary to change the order of cards in the DOM after one card has moved, which triggers repititions of animations. If I didn't do this, my model of the game state would be a nightmare.
    </p>
    <h2>Virtual DOM</h2>
    <p>
      Unlike jQuery, which encourages developers to work with references to long-lived HTML elements objects, and tell them to mutate by fiat, the concept of virtual DOM takes a more data-driven approach.
      Through a virtual DOM architecture you change the state of your program's model, and expect something to happen on screen the next time the renderer runs its view function.
    </p>
    <p>
      Here's an example of two different data structures that would be fed to a virtual DOM renderer. One before placing the Queen of Paper on the table, and one after. This approach works, but requires special attention.
    </p>
    <figure>
      <code-mirror mode="elm"><!--
frameOne =
    div [ class "table-top" ]
        [ QueenOfPaper
        , OneOfRock
        , TwoOfRock
        , ThreeOfRock
        ]


frameTwo =
    div [ class "table-top" ]
        [ OneOfRock
        , TwoOfRock
        , ThreeOfRock
        , PlacedQueenOfPaper
        ]--></code-mirror>
      <figcaption>If only it were this simple</figcaption>
    </figure>
    <p>
      How is a virtual-DOM-diffing algorithm to know that, between frames, an HTML element which was the first child of its parent is now the same one as the fourth child, but with different attributes?
      How fast could that be?
    </p>
    <p>Probably unbearably slow.</p>
    <p>
      By this reasoning my choice of virtual DOM renderer seems irrelevant, in terms of animation.
      I'd expect the same challenge to arise with <a href="https://infernojs.org/">Inferno</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://reactjs.org/">React</a> or whatever your favorite flavor is.
    </p>
    <p>Here's what that lack of clairvoyance on the renderer's part looks like.</p>
    <figure>
      <section id="naiveDemo"></section>
      <figcaption>An illustration of an early attempt</figcaption>
    </figure>
    <p>
      The demonstration above is written in a loop that keeps placing the leftmost card on the table.
      Watch the rank number on the rightmost card closely.
      See how sometimes it switches then goes to the table?
      That's the unwanted CSS transition.
    </p>
    <h2>Solution</h2>
    <p>It seems obvious in retrospect. Don't animate when rearranging the cards in the DOM.</p>
    <figure>
      <code-mirror mode="css"><!--
/* in table-top.css */
.table-top:not([no-transition]) pilatch-card {
  transition-duration: 1s;
}

/* in pilatch-card.css */
:host(:not([no-transition])) #front,
:host(:not([no-transition])) #back {
  /* flip speed goes here */
  transition: transform 0.6s;
}
--></code-mirror>
      <figcaption>Thank you, <code>no-transition</code> attribute</figcaption>
    </figure>
    <p>
      With the above CSS, cards will transition unless we specifically tell them not to.
      That's exactly what happens during the rearrange step by adding the <code>no-transition</code> attribute to each card.
    </p>
    <figure>
      <code-mirror mode="xml"><!--
<pilatch-card no-transition hand="1" rank="12" suit="scissors"></pilatch-card>
<pilatch-card no-transition hand="2" rank="7" suit="paper"></pilatch-card>
<pilatch-card no-transition hand="3" rank="1" suit="paper"></pilatch-card>
<pilatch-card no-transition placed rank="10" suit="rock"></pilatch-card>
--></code-mirror>
      <figcaption>How to only have animations when we want them</figcaption>
    </figure>
    <h2>Exploding Animations</h2>
    <p>
      Placing a card on the table is a single action, but it takes two separate renders to make it happen smoothly and not <em>bork</em> your program's state.
      So the server would send a message to the clients, saying "Player one placed the second card in her hand on the table."
      Then client-side code would explode that animation into the steps that it needs to render.
    </p>
    <figure>
      <code-mirror mode="elm"><!--

type AnimationFromServer
    = PlaceCardAnimation
    | DrawCardAnimation
    -- ...


type RenderStep
    = PlaceStep
    | DrawStep
    | NoTransitionRearrange
    -- ...


explode : AnimationFromServer -> List RenderStep
explode animation =
    case animation of
        PlaceCard ->
            [ PlaceStep, NoTransitionRearrange ]

        -- ...

  --></code-mirror>
      <figcaption>Simple example of how to convert an abstract animation into something actionable</figcaption>
    </figure>
    <p>
      The server sends high-level updates of the game state via <a href="https://socket.io/">socket.io</a>, which Elm decodes from JSON into a type like <code>AnimationFromServer</code>.
    </p>
    <p>
      The <code>explode</code> function is what knows the render steps necessary to make it look good on screen.
    </p>
    <p>If you're interested in the nitty gritty, read on.</p>
    <h2>Iterative Development</h2>
    <p>In each demonstration you can step through the animations by clicking the NEXT button that appears in the upper left corner.</p>
    <p>The goal is the same in each: to place the five of paper face-down, rearrange the remaining cards in hand, then return the card to hand.</p>
    <p><a href="iterations.html">See the bumpy road to success.</a></p>
    <h2>Technologies</h2>
    <p>
      <a href="technologies.html">I took a swing at a few technologies before settling on Elm.</a>
    </p>
  </main>
  <script>
  Array.prototype.forEach.call(document.querySelectorAll('code-mirror'), element => {
    const mode = element.getAttribute('mode')
    let code = element.childNodes[0].textContent.trim()

    if (mode === 'xml' || mode.startsWith('html')) {
      code = code.replace(/--&gt;/g, '-->')
    }

    CodeMirror(element, {
      lineNumbers: true,
      readOnly: false,
      theme: 'monokai',
      mode: mode,
      value : code
    })
  })
  </script>
</body>
</html>
