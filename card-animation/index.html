<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Card Animation Demonstrations</title>
  <link rel="stylesheet" type="text/css" href="https://staticresource.com/template/css/basic.css">
  <script src="public/js/define-custom-element.js"></script>
  <link rel="stylesheet" href="public/css/variables.css">
  <link rel="stylesheet" href="public/css/table-top.css">
  <link rel="import" href="public/html/pilatch-card.html">
  <script src="public/js/Elm.Explanation.Main.js"></script>
  <style>
  body {
    max-width: none;
  }
  header h1 + p {
    font-size: 1.5em;
    text-align: center;
  }
  figure {
    margin: 0;
  }
  figcaption {
    text-align: center;
  }
  figure pre {
    margin-bottom: 1em;
  }
  .explanation {
    margin: 0 auto;
    max-width: 54em;
    padding: 0 1em 2em;
  }
  .explanation .table-top {
    --table-top-height: 400px;
    height: var(--table-top-height);
    margin-top: 1em;
  }
  .explanation .player-placed-card-area {
    top: 45px;
  }
  .player-hand {
    top: 250px;
  }
  </style>
</head>
<body>
  <main class="explanation">
    <header>
      <h1>Card Animations</h1>
      <p>Using web components, Elm, and CSS transitions</p>
    </header>
    <div id="demo"></div>
    <p>
      I wanted to make an online card game. At the least it would need realistic visualizations of cards moving from a player's hand to the table-top. Several years ago I had done something similar with game demonstrations that were meant to augment textual
      rules.
      <a href="https://pilatch.com/games/casual/Runway">You can see one here.</a> Click the "Watch the Demo" button when you get there.</p>
    <p>
      Back then I used jQuery to move around a known set of cards in a pre-determined order. This time such an approach would not be advisable. TODO write more. My initial attempt involved creating a web component for each spot in the game, like so:</p>
    <figure><pre>&lt;pilatch-hand&gt;
    &lt;pilatch-card rank="5" suit="scissors"&gt;&lt;/pilatch-card&gt;
    &lt;pilatch-card rank="12" suit="rock"&gt;&lt;/pilatch-card&gt;
    &lt;pilatch-card rank="1" suit="paper"&gt;&lt;/pilatch-card&gt;
  &lt;/pilatch-hand&gt;
  &lt;placed-card-area&gt;&lt;/placed-card-area&gt;
  </pre>
      <figcaption>A hand of three pilatch cards with an empty area waiting for the player to place a card</figcaption>
    </figure>
    <p>
      Each web component was responsible for positioning the cards contained within it, which was great for abstraction and separation of concerns. However it failed because the concept of moving a card from the hand to the placed card area didn't apply in
      virtual DOM. The renderer would destroy the card that was in the hand, and re-make it at its destination. That didn't play well with animations, as cards would just pop in and out of existence.</p>
    <p>The next concept was to have a table-top element that would contain each game element without additional nesting. The table-top's style is <code>position: relative;</code> and each card within it is <code>position: absolute;</code> allowing the cards
      to float around on the table top by adding or removing CSS classes from them.
    </p>
    <p>Using this approach I could place a card from the player's hand just by adding an attribute to it, such as <code>placed</code>.</p>
    <figure><pre>&lt;pilatch-card hand-1 rank="5" suit="scissors"&gt;&lt;/pilatch-card&gt;
  &lt;pilatch-card placed hand-2 rank="12" suit="rock"&gt;&lt;/pilatch-card&gt;
  &lt;pilatch-card hand-3 rank="1" suit="paper"&gt;&lt;/pilatch-card&gt;
  </pre>
      <figcaption>A hand of two pilatch cards, with the queen of rock placed on the table</figcaption>
    </figure>
    <p>
      Yet a problem arose with this approach too because it's still necessary to move a card in the DOM after it has been animated, which triggered unwanted animations. If you didn't do this, your model of the game state would be a nightmare. To explain, in
      the example above I would need a separate render thereafter to remove the <code>card-2</code> attribute from the middle card, put it underneath the two cards in the player's hand, and nudge the one of paper from <code>card-3</code> to <code>card-2</code>    to make the remaining cards in hand fill the gap that was left by the placed card. So it would have looked like this:</p>
    <figure><pre>&lt;pilatch-card hand-1 rank="5" suit="scissors"&gt;&lt;/pilatch-card&gt;
  &lt;pilatch-card hand-2 rank="1" suit="paper"&gt;&lt;/pilatch-card&gt;
  &lt;pilatch-card placed rank="12" suit="rock"&gt;&lt;/pilatch-card&gt;
  </pre>
      <figcaption>So close to a workable implementation!</figcaption>
    </figure>
    <h2>Solution</h2>
    <p>When rearranging the cards in the DOM, I had to turn off CSS animations. It took a number of iterations to come to this conclusion.</p>
    <p>In each demonstration you can step through the animations by clicking the NEXT button that appears in the upper left corner.</p>
    <p>The goal is the same in each: to place the five of paper face-down, rearrange the remaining cards in hand, then return the card to hand.</p>
    <h2><a href="iterations.html">Iterations</a></h2>
  </main>
</body>
<script>
Elm.Explanation.Main.embed(document.getElementById('demo'), Math.floor(Math.random() * 10000))
</script>
</html>
